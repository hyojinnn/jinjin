# 12. 싱글톤/ final과 start키워드/ 초기화 블럭/ 객체배열



* 싱글톤(singleton)
* static을 이용한 싱글톤 패턴

애플리케이션이 시작될 때 어떤 클래스가 최초 한번만 메모리를 할당하고 그 메모리에 인스턴스를 만들어서 하나의 인스턴스를 공유해서 메모리 낭비를 방지할 수 있게 한다.

(매번 인스턴스 생성하지 않아도 된다)

장점

1. 첫 번째 이용시에는 인스턴스를 생성해야 하므로 속도 차이가 나지 않지만 두 번째 이용시에는 인스턴스 생성 시간 없이 사용할 수 있다.
2. 인스턴스가 절대적으로 한 개만 존재하는 것을 보증할 수 있다.

단점

1.  싱글톤 인스턴스가 너무 많은 일을 하거나 많은 데이터를 공유하면 결합도가 높아진다.

    ```
    (유지보수와 테스트에 문제점이 있다.)
    ```
2. 동시성 문제를 고려해서 설계해야 하기 때문에 난이도가 있다

* 싱글톤 구현 방법

1. 이른 초기화(Eager Initialzation) 구현

getInstance() 메소드를 호출해야만 인스턴스를 생성할 수 있다.

```jsx
EagerSingleton eager1 = EagerSingleton.getInstance();
EagerSingleton eager2 = EagerSingleton.getInstance();
		
		System.err.println("eager1의 hashcode : " + eager1.hashCode());
		System.out.println("eager2의 hashcode : " + eager2.hashCode());
		// 두 인스턴스가 hashcode가 동일한 것을 확인할 수 있다.
		// (동일한 인스턴스)
```

2\. 게으른 초기화 구현

```jsx
LazySingleton lazy1 = LazySingleton.getInstance();
LazySingleton lazy2 = LazySingleton.getInstance();
		
		System.out.println("lazy1의 hashcode : " + lazy1.hashCode());
		System.out.println("lazy2의 hashcode : " + lazy2.hashCode());
```

* 이른 초기화를 사용하면 클래스를 로드하는 속도가 느려지지만 처음 인스턴스 반환 요청에서 속도가 빠르다는 장점을 가진다. 반면 게으른 초기화는 클래스를 로드하는 속도가 빠르지만 첫 번째 요청에 대한 속도가 두번째 요청에 대한 속도보다 느리다는 특징이 있다.
* static

정적 메모리 영역에 프로그램이 start 할 때 할당을 하는 키워드. 여러 인스턴스가 공유해서 사용할 목적의 공간이다.

* final

final은 중단의 의미를 가지는 키워드이다. final 키워드를 사용할 수 있는 위치는 다양한 편이며 의미가 약간 다르지만 결국 변경 불가의 의미이다.

1. 지역변수 : 초기화 이후 값 변경 불가
2. 매개변수 : 호출 시 전달한 인자 변경 불가
3. 전역변수 : 인스턴스 생성 후 초기화 이후에 값 변경 불가
4. 클래스(static) 변수 : 프로그램 start 이후 값 변경 불가
5. non-static 메소드 : 메소드 재작성(overriding) 불가
6. static 메소드 : 메소드 재작성(overriding) 불가
7. 클래스 : 상속 불가

* 초기화블럭

복잡한 초기화를 수행할 수 있는 블럭을 제공하며, 인스턴스 초기화블럭과 정적 초기화 블럭으로 구분한다.

1. 인스턴스 초기화 블럭

인스턴스가 생성되는 시점에 생성자 호출 이전에 먼저 실행이 된다. 인스턴스를 호출하는 시점마다 호출이 된다. 인스턴스변수를 초기화하며 정적필드에는 실행시점마다 값을 덮어쓴다.

```jsx
{
	초기화 내용 작성
}
```

2\. 정적 초기화 블럭

클래스가 로드될 때 한 번 동작한다. 정적 필드를 초기화하며, 인스턴스 변수는 초기화하지 못한다.

```jsx
static {
		초기화 내용 작성
}
```

* 인스턴스변수 : 기본값 -> 명시적초기값 -> 인스턴스초기화블럭 - > 생성자
* 클래스변수 : 기본값 -> 명시적초기값 -> 정적초기화블럭 -> 인스턴스초기화블럭 -> 생성자
* 객체배열

객체배열은 레퍼런스변수에 대한 배열이다. 생성한 인스턴스도 배열을 이용해서 관리하면 동일한 타입의 여러 개 인스턴스를 각각 취급하지 않고 연속 처리할 수 있어서 유용하다.

또한 반환값은 1개의 값만 반환할 수 있기 때문에 동일한 타입의 여러 인스턴스를 반환해야 하는 경우 객체배열을 이용할 수 있다.

```jsx
Car[] carArray = new Car[5];

carArray[0] = new Car("페라리", 300);
carArray[1] = new Car("람보르기니", 350);
carArray[2] = new Car("롤스로이스", 250);
carArray[3] = new Car("부가티베이론", 400);
carArray[4] = new Car("포터", 500);
```
