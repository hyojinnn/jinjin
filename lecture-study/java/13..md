# 13. 상속



* 상속

상속(inheritance)은 현실 세계의 상속과 비슷한 개념이다.

부모가 가지고 있는 재산(자바에서는 클래스가 가지는 멤버)을 자식이 물려받는 의미이다.

단순히 물려받는 개념보다 조금 더 나아간다면 자바에서의 상속은 부모클래스의 확장(extend)의 개념을 가진다.

물려받아서 자신의 것처럼 사용하는 것 뿐만 아니라 추가적인 멤버도 작성이 가능하다.

* 메소드 재정의(overriding)라는 기술을 이용해서 부모가 가진 메소드를 재정의 하는 것도 가능하다.

메소드 재정의(Overriding)란 ?

부모가 가지는 메소드 선언부를 그대로 사용하면서 자식클래스가 정의한 메소드대로 동작하도록 구현 몸체 부분을 새롭게 다시 작성하는 기술이다.

메소드 재정의를 하면 메소드를 호출할 시 재정의한 메소드가 우선적으로 동작하게 된다.

```jsx
public RacingCar() {
		System.out.println("RacingCar 클래스 기본 생성자 호출됨...");
	}
	
	@Override
	public void run() {
		
		System.out.println("레이싱카가 전속력으로 질주합니다!!!!");
	}
```

* super / super()

super : 자식클래스를 이용해서 객체를 생성할 때 부모 생성자를 호출하여 부모클래스의 인스턴스도 함께 생성하게 된다. 이 때 생성한 부모의 인스턴스 주소를 보관하는 레퍼런스 변수로 자식 클래스 내의 모든 생성자와 메소드내에서 선언하지 않고도 사용할 수 있는 레퍼런스 변수이다.

super() : 부모 생성자를 호출하는 구문으로 인자와 매개변수의 타입, 갯수, 순서가 일치하는 부모의 생성자를 호출하게 된다. this()가 해당 클래스 내의 다른 생성자를 호출하는 구문이라면, super()는 부모클래스가 가지는 private 생성자를 제외한 나머지 생성자를 호출할 수 있도록 한 구문이다.

```jsx
public ComputerDTO(String cpu, int hdd, int ram, String operationSystem) {
// 부모 클래스의 기본생성자 호출
super();
this.cpu = cpu;
this.hdd = hdd;
this.ram = ram;
this.operationSystem = operationSystem;

System.out.println("ComputerDTO 클래스의 모든 필드를 초기화하는 생성자 호출함");
}
```

* 오버라이딩

부모클래스에서 상속받은 메소드를 자식클래스에서 재정의하여 사용하는 것이다.

```jsx
/* 오버라이딩 성립 조건 */
1. 메소드의 이름이 동일해야 한다.
2. 메소드의 리턴 타입이 동일해야 한다.
3. 매개변수의 타입, 갯수, 순서가 동일해야 한다.
4. private 메소드는 접근이 불가능하기 때문에 오버라이딩이 불가능하다.
5. final 키워드가 사용된 메소드는 오버라이딩이 불가능하다.
6. 접근제한자는 부모 메소드와 같거나 더 넓은 범위여야 한다.
```

* 메소드 이름 변경하면 에러 발생
* 메소드의 리턴타입 변경하면 에러 발생
* 매개변수 갯수나, 타입이 변경되면 에러 발생
